#!/bin/bash
# Check Python availability
if command -v python3 > /dev/null 2>&1; then
   python_cmd="python3"
elif command -v python > /dev/null 2>&1; then
   python_cmd="python"
else
   echo "WARNING: Python3 is not installed. Commit review functionality will not work."
   exit 1
fi

# Function to check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to display a Tkinter message box
show_message_box() {
    local message="$1"
    $python_cmd - <<EOF
import tkinter as tk
from tkinter import messagebox
root = tk.Tk()
root.withdraw()
messagebox.showinfo("Genie GitHooks", '$message')
EOF
}

# Function to extract and open HTML from API response
open_html_in_browser() {
    local api_response="$1"
    # Use cross-platform mktemp (macOS doesn't support --suffix)
    local temp_file=$(mktemp).html
    local temp_response_file=$(mktemp)
    
    # Write response to a temp file to avoid bash multiline string issues
    printf '%s' "$api_response" > "$temp_response_file"
    
    # Use Python to properly extract HTML from the response
    $python_cmd - <<EOF
import json
import sys
import webbrowser

response_file = '$temp_response_file'
html_file = '$temp_file'

try:
    # Read the response from temp file
    with open(response_file, 'r', encoding='utf-8') as f:
        api_response = f.read()
    
    # Try to parse as JSON first (in case the HTML is wrapped in JSON)
    html_content = api_response
    try:
        parsed = json.loads(api_response)
        if isinstance(parsed, dict):
            # Check for common HTML response keys
            for key in ['html', 'content', 'response', 'data']:
                if key in parsed:
                    html_content = parsed[key]
                    break
    except json.JSONDecodeError:
        pass
    
    # Write HTML to temp file
    with open(html_file, 'w', encoding='utf-8') as f:
        f.write(html_content)
    
    # Open in browser
    webbrowser.open('file://' + html_file)
    
except Exception as e:
    # Fallback: write raw response to file
    try:
        with open(response_file, 'r', encoding='utf-8') as f:
            raw_content = f.read()
        with open(html_file, 'w', encoding='utf-8') as f:
            f.write(raw_content)
        webbrowser.open('file://' + html_file)
    except Exception as e2:
        pass
EOF
    
    # Clean up temp response file
    rm -f "$temp_response_file"
}

# Function to detect programming language from file extensions
detect_language() {
    local files="$1"
    
    $python_cmd - <<EOF
import sys
import os
files = """$files""".strip().split('\n')

# Check for special file patterns first
special_files = {
    'requirements.txt': 'python',
    'pyproject.toml': 'python',
    'setup.py': 'python',
    'setup.cfg': 'python',
    'pipfile': 'python',
    'pipfile.lock': 'python',
    'poetry.lock': 'python',
    'conda.yaml': 'python',
    'environment.yml': 'python',
    'package.json': 'javascript',
    'package-lock.json': 'javascript',
    'yarn.lock': 'javascript',
    'bower.json': 'javascript',
    'webpack.config.js': 'javascript',
    'gulpfile.js': 'javascript',
    'gruntfile.js': 'javascript',
    'dockerfile': 'docker',
    'docker-compose.yml': 'docker',
    'docker-compose.yaml': 'docker',
    'makefile': 'makefile',
    'rakefile': 'ruby',
    'gemfile': 'ruby',
    'gemfile.lock': 'ruby',
    'cargo.toml': 'rust',
    'cargo.lock': 'rust',
    'pom.xml': 'java',
    'build.gradle': 'java',
    'composer.json': 'php',
    'composer.lock': 'php'
}

# Check if any files match special patterns
for file in files:
    filename = os.path.basename(file).lower()
    if filename in special_files:
        print(special_files[filename])
        exit()

# If no special files found, proceed with extension-based detection
extensions = {}
for file in files:
    if '.' in file:
        ext = file.split('.')[-1].lower()
        extensions[ext] = extensions.get(ext, 0) + 1

# Enhanced language mapping
lang_map = {
    'py': 'python',
    'pyx': 'python',
    'pyi': 'python',
    'js': 'javascript',
    'jsx': 'javascript',
    'ts': 'typescript',
    'tsx': 'typescript',
    'java': 'java',
    'class': 'java',
    'jar': 'java',
    'cpp': 'cpp',
    'cxx': 'cpp',
    'cc': 'cpp',
    'c': 'c',
    'h': 'c',
    'hpp': 'cpp',
    'cs': 'csharp',
    'php': 'php',
    'php3': 'php',
    'php4': 'php',
    'php5': 'php',
    'rb': 'ruby',
    'ruby': 'ruby',
    'go': 'go',
    'rs': 'rust',
    'kt': 'kotlin',
    'kts': 'kotlin',
    'swift': 'swift',
    'html': 'html',
    'htm': 'html',
    'css': 'css',
    'scss': 'scss',
    'sass': 'scss',
    'less': 'css',
    'sql': 'sql',
    'mysql': 'sql',
    'postgresql': 'sql',
    'sh': 'bash',
    'bash': 'bash',
    'zsh': 'bash',
    'fish': 'bash',
    'yml': 'yaml',
    'yaml': 'yaml',
    'json': 'json',
    'jsonc': 'json',
    'xml': 'xml',
    'xsd': 'xml',
    'xsl': 'xml',
    'md': 'markdown',
    'markdown': 'markdown',
    'txt': 'text',
    'text': 'text',
    'log': 'text',
    'cfg': 'text',
    'conf': 'text',
    'config': 'text',
    'ini': 'text',
    'properties': 'text',
    'env': 'text',
    'toml': 'toml',
    'dockerfile': 'docker',
    'makefile': 'makefile',
    'mk': 'makefile'
}

if extensions:
    most_common_ext = max(extensions, key=extensions.get)
    print(lang_map.get(most_common_ext, 'unknown'))
else:
    print('unknown')
EOF
}

# Check if Git is installed
if ! command_exists git; then
    show_message_box "Error: Git is not installed. Please install Git before proceeding."
    exit 1
fi

# Check if Git global username and email are set
GIT_USERNAME=$(git config --global user.name)
GIT_EMAIL=$(git config --global user.email)
 
if [ -z "$GIT_USERNAME" ] || [ -z "$GIT_EMAIL" ]; then
    show_message_box 'Error: Git global username and/or email is not set.\nPlease configure them using: \n git config --global user.name "Your Name" \n git config --global user.email  "you@example.com"'
    exit 1
fi

# Get staged files and diff content
staged_files=$(git diff --cached --name-only)
diff_content=$(git diff --cached)
repo_name=$(git config --get remote.origin.url | sed 's#.*/##;s/.git//' 2>/dev/null || basename "$(pwd)")
branch_name=$(git rev-parse --abbrev-ref HEAD)

if [[ -z "$staged_files" ]]; then
    show_message_box "No files staged for commit."
    exit 0
fi

if [[ -z "$diff_content" ]]; then
    show_message_box "No changes detected in staged files."
    exit 0
fi

# Detect programming language
language=$(detect_language "$staged_files")

# Create JSON payload using Python to handle proper escaping
json_file=$(mktemp)
printf '%s' "$diff_content" | $python_cmd - <<EOF > "$json_file"
import json
import sys

# Read the diff content from stdin
diff_content = sys.stdin.read()

# Create the payload with proper JSON encoding
payload = {
    "code": diff_content,
    "language": "$language",
    "project_name": "$repo_name", 
    "branch_name": "$branch_name",
    "html": True
}

# Output the JSON
print(json.dumps(payload))
EOF

# Get JWT token for authentication
jwt_token=""
if [ -f "$HOME/.genie/token" ]; then
    jwt_token=$(cat "$HOME/.genie/token" 2>/dev/null)
fi

if [ -z "$jwt_token" ]; then
    show_message_box "ERROR: Authentication token not found. Please run the Genie GitHooks app to login again."
    exit 1
fi

# Send to new API endpoint with authentication
api_url="${BASE_API}/review/review"

response=$(curl -s -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $jwt_token" -d @"$json_file" "$api_url")
rm "$json_file"

# Check response
if [ -z "$response" ]; then
    show_message_box "ERROR: Unable to communicate with the server. Check internet connection or server status."
    exit 1
fi

# Check for authentication errors
if [[ "$response" == *'"detail":'* ]] && [[ "$response" == *'"Unauthorized"'* ]]; then
    show_message_box "ERROR: Authentication failed. Your session may have expired.\nPlease run the Genie GitHooks app to login again."
    exit 1
fi

if [[ "$response" == *'"detail":'* ]] && [[ "$response" == *'"Invalid token"'* ]]; then
    show_message_box "ERROR: Authentication token is invalid.\nPlease run the Genie GitHooks app to login again."
    exit 1
fi

# Check if response contains error
if [[ "$response" == *'"detail":'* ]] && [[ "$response" == *'"Not Found"'* ]]; then
    show_message_box "ERROR: API endpoint not found. Please check server configuration."
    exit 1
fi

# Open HTML response in browser
open_html_in_browser "$response"

exit 0